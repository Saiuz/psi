<!-- Copyright (c) Microsoft Corporation. All rights reserved.
     Licensed under the MIT License. -->
<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=9" />
    <meta name="generator" content="Doxygen 1.8.14" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Platform for Situated Intelligence: Microsoft.Psi.Components Namespace Reference</title>
    <link href="tabs.css" rel="stylesheet" type="text/css" />
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <link href="customdoxygen.css" rel="stylesheet" type="text/css" /> 
</head>
<body>
    <div id="top">
        <!-- do not remove this div, it is closed by doxygen! -->
        <div id="titlearea">
            <table cellspacing="0" cellpadding="0">
                <tbody>
                    <tr style="height: 56px;">
                        <td id="projectalign" style="padding-left: 0.5em;">
                            <div id="projectname">Platform for Situated Intelligence</div>
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>
        <!-- end header part --><!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_microsoft.html">Microsoft</a></li><li class="navelem"><a class="el" href="namespace_microsoft_1_1_psi.html">Psi</a></li><li class="navelem"><a class="el" href="namespace_microsoft_1_1_psi_1_1_components.html">Components</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle">
<div class="title">Microsoft.Psi.Components Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_psi_1_1_components_1_1_aggregator.html">Aggregator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A stateful transform.  <a href="class_microsoft_1_1_psi_1_1_components_1_1_aggregator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_psi_1_1_components_1_1_async_consumer_producer.html">AsyncConsumerProducer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple transform component.  <a href="class_microsoft_1_1_psi_1_1_components_1_1_async_consumer_producer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_psi_1_1_components_1_1_buffer_select.html">BufferSelect</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a buffering component. The component adds each incoming message to the buffer and trims the buffer by evaluating a remove condition.  <a href="class_microsoft_1_1_psi_1_1_components_1_1_buffer_select.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_psi_1_1_components_1_1_connector.html">Connector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pass-through component, to be used when writing meta-components. The encapsulating component (the meta-component) can use this class instead of a receiver. This allows the code within the meta-component to attach operators to the output of the connector, while exposing the input property of the connector as a public receiver.  <a href="class_microsoft_1_1_psi_1_1_components_1_1_connector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_psi_1_1_components_1_1_consumer_producer.html">ConsumerProducer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the base class for any component that transforms an input type into an output type. Derive from thsi class if your component has more than one input or more than one output. Otherwise, use one of the the Operators.Select&lt;TIn, TOut&gt;(IProducer&lt;TIn&gt;, System.Func&lt;TIn, Envelope, TOut&gt;, DeliveryPolicy) or Operators.Process&lt;TIn, TOut&gt;(IProducer&lt;TIn&gt;, System.Action&lt;TIn, Envelope, Emitter&lt;TOut&gt;&gt;, DeliveryPolicy) operators.  <a href="class_microsoft_1_1_psi_1_1_components_1_1_consumer_producer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_psi_1_1_components_1_1_deserializer_component.html">DeserializerComponent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserializer optimized for streaming scenarios, where buffers and instances can be cached.  <a href="class_microsoft_1_1_psi_1_1_components_1_1_deserializer_component.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_psi_1_1_components_1_1_event_source.html">EventSource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generator component that publishes messages of a specified type whenever an event is raised.  <a href="class_microsoft_1_1_psi_1_1_components_1_1_event_source.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_psi_1_1_components_1_1_generator.html">Generator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a sequence of messages at the pace dictated by the pipeline. Use this base class when your generator has multiple output streams. Use the static functions of the <a class="el" href="class_microsoft_1_1_psi_1_1_generators.html" title="Factory methods for instantiating generators. ">Generators</a> class for the single-stream case.  <a href="class_microsoft_1_1_psi_1_1_components_1_1_generator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_microsoft_1_1_psi_1_1_components_1_1_i_consumer_producer.html">IConsumerProducer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface representing a component that is both a consumer and producer of messages.  <a href="interface_microsoft_1_1_psi_1_1_components_1_1_i_consumer_producer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_microsoft_1_1_psi_1_1_components_1_1_i_finite_source_component.html">IFiniteSourceComponent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface indicating that a component is a finite "source" of messages; generators, etc. Components that implement this interface should advise the pipeline when they are done posting messages. Reactive components that generate messages only in response to incoming messages should not implement this interface. A pipeline containing source components will shut down only once all sources have completed (or earlier if explicitly stopped/disposed).  <a href="interface_microsoft_1_1_psi_1_1_components_1_1_i_finite_source_component.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_microsoft_1_1_psi_1_1_components_1_1_i_source_component.html">ISourceComponent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marker interface indicating that a component is a "source" of messages; sensor inputs, generators, etc. Reactive components that generate messages only in response to incoming messages should not implement this interface. A source component that has a concept of "completion" should implement <a class="el" href="interface_microsoft_1_1_psi_1_1_components_1_1_i_finite_source_component.html" title="Interface indicating that a component is a finite &quot;source&quot; of messages; generators, etc. Components that implement this interface should advise the pipeline when they are done posting messages. Reactive components that generate messages only in response to incoming messages should not implement this interface. A pipeline containing source components will shut down only once all sources have completed (or earlier if explicitly stopped/disposed). ">IFiniteSourceComponent</a>. A pipeline containing source components will shut down only once all sources have completed (or earlier if explicitly stopped/disposed).  <a href="interface_microsoft_1_1_psi_1_1_components_1_1_i_source_component.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_psi_1_1_components_1_1_join.html">Join</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a merge between a pair of streams  <a href="class_microsoft_1_1_psi_1_1_components_1_1_join.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_psi_1_1_components_1_1_merger.html">Merger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines the input messages from multiple inputs into a single output.  <a href="class_microsoft_1_1_psi_1_1_components_1_1_merger.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_psi_1_1_components_1_1_pair.html">Pair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a wall-clock based pairing of streams; taking the last (or provided initial) value from the secondary.  <a href="class_microsoft_1_1_psi_1_1_components_1_1_pair.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_psi_1_1_components_1_1_parallel.html">Parallel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and applies a sub-pipeline to each element in the input array. The input array must have the same length across all messages. The sub-pipelines have index affinity, meaning the same sub-pipeline is re-used across multiple messages for the entry with the same index.  <a href="class_microsoft_1_1_psi_1_1_components_1_1_parallel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_psi_1_1_components_1_1_parallel_sparse.html">ParallelSparse</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and applies a sub-pipeline to each element in the input collection. The sub-pipelines have key affinity, meaning the same sub-pipeline is re-used across multiple messages for the entry with the same key.  <a href="class_microsoft_1_1_psi_1_1_components_1_1_parallel_sparse.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_psi_1_1_components_1_1_parallel_variable_length.html">ParallelVariableLength</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and applies a sub-pipeline to each element in the input array. The input array can have variable length. The sub-pipelines have index affinity, meaning the same sub-pipeline is re-used across multiple messages for the entry with the same index in the array.  <a href="class_microsoft_1_1_psi_1_1_components_1_1_parallel_variable_length.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_psi_1_1_components_1_1_processor.html">Processor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Component that wraps a transform delegate which processes input messages and optionally publishes results. There is no assumption regarding the number of input messages needed to produce a result, or the number of output messages resulting from one input message. If the transform is stateful, special care needs to be taken when storing input message data. The input message payload is only valid for the duration of the transform call. If the data needs to be stored beyond the scope of this method, use the extension method Serializer.DeepClone&lt;T&gt;(T, ref T) to create a private copy.  <a href="class_microsoft_1_1_psi_1_1_components_1_1_processor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_psi_1_1_components_1_1_repeater.html">Repeater</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs the last input message on every clock tick.  <a href="class_microsoft_1_1_psi_1_1_components_1_1_repeater.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_psi_1_1_components_1_1_sampler.html">Sampler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">I  <a href="class_microsoft_1_1_psi_1_1_components_1_1_sampler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_psi_1_1_components_1_1_serializer_component.html">SerializerComponent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializer optimized for streaming scenarios, where buffers and instances can be cached.  <a href="class_microsoft_1_1_psi_1_1_components_1_1_serializer_component.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_psi_1_1_components_1_1_simple_consumer.html">SimpleConsumer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple consumer  <a href="class_microsoft_1_1_psi_1_1_components_1_1_simple_consumer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_psi_1_1_components_1_1_splitter.html">Splitter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends the input message to at most one of the dynamic outputs, selected using the specified output selector.  <a href="class_microsoft_1_1_psi_1_1_components_1_1_splitter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_psi_1_1_components_1_1_timer.html">Timer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple producer component that wakes up on a predefined interval and publishes a simple message. This is useful for components that need to poll some resource. Such components can simply subscribe to this clock component rather than registering a timer on their own.  <a href="class_microsoft_1_1_psi_1_1_components_1_1_timer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
<!-- Copyright (c) Microsoft Corporation. All rights reserved.
     Licensed under the MIT License. -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer" />
<address class="footer">
  <small>
    <a href="https://go.microsoft.com/fwlink/?LinkId=521839">Privacy & Cookies</a>&nbsp;|&nbsp;
    <a href="https://go.microsoft.com/fwlink/?LinkId=246338">Terms Of Use</a>&nbsp;|&nbsp;
    <a href="https://go.microsoft.com/fwlink/?LinkId=506942">Trademarks</a>&nbsp;|&nbsp; &nbsp;&#9400;&nbsp;Microsoft
    <img class="footer" src="MSLogoGreySmall.png" alt="Microsoft" Height="40" /> Generated by&nbsp;
    <a href="http://www.doxygen.org/index.html">
      <img class="footer" src="doxygen.png" alt="doxygen" />
    </a>1.8.14
  </small>
</address>
</body>
</html>